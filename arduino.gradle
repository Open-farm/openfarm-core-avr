/*
import com.sun.jna.platform.win32.Kernel32;
import java.io.ByteArrayOutputStream;
import java.io.StringReader;
import java.io.BufferedReader;
import java.text.SimpleDateFormat;
import java.util.Locale;

apply from: 'properties.gradle'

buildscript {
  repositories {
    mavenCentral()
  }

  dependencies {
    classpath 'net.java.dev.jna:jna:3.4.0' 
    classpath 'net.java.dev.jna:platform:3.4.0' 
  }
}

def shortBuildDir = short_path(buildDir.absolutePath)

// This class basically forwards a stream to /dev/null
class StreamGobbler extends Thread {
	BufferedInputStream source;
	BufferedOutputStream dest;

	StreamGobbler(InputStream source, OutputStream dest) {
		this.source = new BufferedInputStream(source);
		this.dest = new BufferedOutputStream(dest);
	}

	public void run() {
		try {           
			byte[] b = new byte[100];
			int size = 0;

			while ((size = source.read(b)) > 0) {
				dest.write(b, 0, size)
			}

			dest.flush()
		} catch (IOException ioe) {
			ioe.printStackTrace();
		}
	}
}

// Creates a short path from a regular one. This gets rid of spaces and whatnot.
def short_path(file) {
	char[] output = new char[500];
	def size = Kernel32.INSTANCE.GetShortPathName(file, output, output.length)
	return new String(output, 0, size)
}

// Recursively works down a directory structure, adding all source files to the
// input list.
def add_source_files_in_dir(list, dir) {
	// add .c files
	dir.eachFileMatch(~/.*\.c$/) {
		list << it
	}

	// add .cpp files
	dir.eachFileMatch(~/.*\.cpp$/) {
		list << it
	}

	// recurse
	dir.eachDirRecurse() {
		add_source_files_in_dir(list, it)
	}
}

// Reads through file and adds all includes to the input list.
def add_includes(includes, file) {
	def reader = file.newReader()
	def line = null

	// Pattern copied from Arduino IDE source code: processing.app.preproc.PdePreprocessor.java
	def include_pattern = ~/^\s*#include\s+[<"](\S+)[">]/
	while ((line = reader.readLine()) != null) {
		def matcher = include_pattern.matcher(line)
		if (matcher.matches()) {
			def header = matcher[0][1]
			if (header.endsWith(".h")) {
				header = header.substring(0, header.length() -2)
			}
			
			includes << header
		}
	}
}

// finds libraries for a file
def find_libraries(file, libraries, arduino_files) {
	if (project.hasProperty("verbose")) {
		println("Finding libraries for " + file + ".")
	}
	
	// iterate over all includes for this file
	def includes = []
	add_includes(includes, file)
	includes.each { include ->
		if (project.hasProperty("verbose")) {
			print("\tLooking for include: " + include + "...")
		}
		
		// search all the library directories for this include
		def foundlib = false
		librariesDirs.each { libraryDir ->
			def libdir = new File(libraryDir, include)
			if (libdir.exists() && libdir.isDirectory()) {
				println(" Found library in " + libraryDir)
				
				// add to libraries
				libraries << libdir
				
				// add source in the library directory to the source files list
				add_source_files_in_dir(arduino_files, libdir)
				
				foundlib = true
			}
			else {
				// ?
			}
		}
		
		if (!foundlib) {
			println("No library found.")
		}
	}
}

// Builds a source file.
// file - .c or .cpp file.
// arduino_files - list of source files from Arduinos.
def build_source_file(file, arduino_files) {
	
	// if object file is recent enough, we can skip this build
	def object_file = new File(buildDir, file.name + ".o")
	if (!project.hasProperty('forceRebuild')) {
		if (file.lastModified() < object_file.lastModified())
		return object_file
	}
	
	if (project.hasProperty("verbose")) {
		println("\n\n///////////////////////////////////////////////////////////////////////////////")
		println("Building file : " + file.name)
	}

	def libraries = []
	find_libraries(file, libraries, arduino_files)

	// File.absolutePath doesn't work if the file doesn't exist
	object_file.createNewFile()

	println "Compiling ${file.name}"

	// configuration parameters based on .cpp or .c
	boolean cpp = file.getPath() =~ /.*\.cpp$/
	def noexceptions = cpp ? "-fno-exceptions" : ""
	def compiler = cpp ? "avr-g++" : "avr-gcc";

	def cmd = []
	cmd << "$arduinoDir\\hardware\\tools\\avr\\bin\\$compiler"
	cmd << "-c"
	cmd << "-g"
	cmd << "-Os"
	cmd << "-Wall"
	cmd << "-std=gnu++11"
	cmd << "$noexceptions"
	cmd << "-ffunction-sections"
	cmd << "-fdata-sections"
	cmd << "-fno-threadsafe-statics"
	cmd << "-MMD"
	cmd << "-mmcu=$cpuName"
	cmd << "-DF_CPU=$cpuClock"
	cmd << "-DARDUINO=100"
	cmd << "-DARDUINO_AVR_NANO"
	cmd << "-DARDUINO_ARCH_AVR"
	cmd << "-I${short_path(arduinoCore)}"
	cmd << "-I${short_path(arduinoVariant)}"
	
	// include libraries
	libraries.each { library ->
		cmd << "-I${short_path(library.absolutePath)}"
		library.eachDirRecurse() {
			if (!it.absolutePath.contains("\\examples\\")) {
				cmd << "-I${short_path(it.absolutePath)}"
			}
		}
	}
	
	cmd << "${short_path(file.getAbsolutePath())}"
	cmd << "-o" + short_path(object_file.parent) + "\\" + object_file.name

	exec_cmd(cmd)

	return object_file
}

// Executes a command.
def exec_cmd(cmd) {
	def verbose = project.hasProperty("verbose")

	def command = ""

	def str_cmd = []
	cmd.each {
		command = command + it + " "
		str_cmd << it.toString()
	}

	if (verbose) {
		println command
	}

	def redir_out = verbose ? System.out : new ByteArrayOutputStream()

	def pb = new ProcessBuilder(str_cmd)
	pb.redirectErrorStream(true)
	pb.directory(projectDir)

	def proc = pb.start()
	new StreamGobbler(proc.getInputStream(), redir_out).start()

	def retCode = proc.waitFor()
	if (retCode != 0) {
		if (!verbose) {
			println command
			System.out.print(new String(redir_out.toByteArray()))
		}
		throw new GradleException()
	}
}

def extract_archive_index() {
  def result = [:]
  
  def index = new File(buildDir, "archiveindex.dat")

  if (index.exists()) {
    def reader = index.newReader()
    String line = null
    while ((line = reader.readLine()) != null) {
      def elems = line.split("=", 2)
      result[elems[0]] = Long.parseLong(elems[1])
    }
  }

  return result
}

def save_archive_index(index) {
  def index_file = new File(buildDir, "archiveindex.dat").newPrintWriter()
  index.each {
    index_file.println("${it.key}=${it.value}")
  }
  index_file.flush()
  index_file.close()
}

def archive_object_file(object_file) {
  def cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-ar",
         "rcs",
         "$buildDir\\core.a",
         short_path(object_file.parent) + "\\" + object_file.name]

  exec_cmd(cmd)
}

def link(sketch_object_files) {
	def shortBuildDir = buildDir.absolutePath
	
  def cmd = []
  cmd << "$arduinoDir\\hardware\\tools\\avr\\bin\\avr-gcc"
  cmd << "-w"
  cmd << "-Os"
  cmd << "-Wl,"
  //cmd << "--gc-sections"
  cmd << "-mmcu=$cpuName"
  cmd << "-o $shortBuildDir\\${sketchMainFile}.elf"
  sketch_object_files.each {
    cmd << short_path(it.absolutePath)
  }
  cmd << short_path(buildDir.absolutePath) + "\\core.a"
  cmd << "-L$shortBuildDir"
  cmd << "-lm"
  exec_cmd(cmd)
}

def objcopy() {
  cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-objcopy",
         "-O",
         "ihex",
         "-j",
         ".eeprom",
         "--set-section-flags=.eeprom=alloc,load",
         "--no-change-warnings",
         "--change-section-lma",
         ".eeprom=0",
         "$buildDir\\${sketchMainFile}.elf",
         "$buildDir\\${sketchMainFile}.eep"]
  exec_cmd(cmd)

  cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-objcopy",
         "-O",
         "ihex",
         "-R",
         ".eeprom",
         "$buildDir\\${sketchMainFile}.elf",
         "$buildDir\\${sketchMainFile}.hex"]
  exec_cmd(cmd)
}

def can_skip_archive(index, arduino_object_files) {
  def result = true
  arduino_object_files.each { obj ->
    if (!index.containsKey(obj.name))
      result = false
    else if (obj.lastModified() > index[obj.name])
      result = false
  }

  return result
}

// Task to build source to .hex file.
/*
task build {
	doLast {
		// make directories
		buildDir.mkdirs()
		
		def sketch_files = []
		def arduino_files = []
		def sketch_object_files = []
		def arduino_object_files = []   
		
		// find all source in the project directory
		add_source_files_in_dir(sketch_files, projectDir)
		
		// find all source in the arduinoCode directory
		add_source_files_in_dir(arduino_files, new File(arduinoCore))  

		println "Compiling source files..."
		
		// build each source file in the sketch
		sketch_files.each {
		  sketch_object_files << build_source_file(it, arduino_files)
		}

		// build all the other files the sketch required
		arduino_files.each {
		  arduino_object_files << build_source_file(it, [])
		}

		def archive_index = extract_archive_index()
		if (!can_skip_archive(archive_index, arduino_object_files)) {
		  println "Archiving object files"
		  archive_index.clear()
		  arduino_object_files.each {
			archive_object_file(it)
			archive_index[it.name] = it.lastModified()
		  }
		  save_archive_index(archive_index)
		}

		println "Linking"
		link(sketch_object_files)

		objcopy()
	}
}

// Builds a library folder into a static library.
ext.build_library = { dir, targetDir ->
	
	// get all source in this library
	def source = []
	add_source_files_in_dir(source, dir)
	if (0 == source.size()) {
		return;
	}
	
	println("Compiling library " + dir.name)
	
	// compile source to .o files
	def cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-g++"]
	cmd << "-c"
	cmd << "-g"
	cmd << "-Os"
	cmd << "-Wall"
	cmd << "-std=gnu++11"
	cmd << "-fno-exceptions"
	cmd << "-ffunction-sections"
	cmd << "-fdata-sections"
	cmd << "-fno-threadsafe-statics"
	cmd << "-MMD"
	cmd << "-mmcu=$cpuName"
	cmd << "-DF_CPU=$cpuClock"
	cmd << "-DARDUINO=100"
	cmd << "-DARDUINO_AVR_NANO"
	cmd << "-DARDUINO_ARCH_AVR"
	cmd << "-I${short_path(arduinoCore)}"
	cmd << "-I${short_path(arduinoVariant)}"
	cmd << "-I${short_path(dir.absolutePath)}"
	cmd << "-I${short_path(dir.absolutePath)}\\src"
	
	source.each {
		cmd << "${it.getAbsolutePath()}"
	}
	
	exec_cmd(cmd)
	
	println("\tObject files compiled.")
	
	// build .o files to library
	def libName = "lib${dir.name}.a"
	cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avr-ar"]
	cmd << "rcs"
	cmd << "${targetDir.absolutePath}\\" + libName 
	source.each {
		def name = it.name.split("\\.")[0]
		cmd << "${name}.o"
	}
	
	exec_cmd(cmd)
	
	println("\tObject files built to " + targetDir.absolutePath)
}
/*
// Cleans temp files created from compilation.
task cleanTemp {
	doLast {
		println("Cleaning temp files from " + buildDir.parent)
		
		new File(buildDir.parent).eachFileMatch(~/.*\.[aod]$/) {
			it.delete()
		}
	}
}

// Builds each library into a static library.
task buildLibraries(dependsOn: cleanTemp) {
	doLast {
		def staticDir = new File(staticLibraryDir)
		if (staticDir.exists()) {
			staticDir.deleteDir()
		}
		staticDir.mkdir()
		
		librariesDirs.each {
			if (it ==~ /^\./ || it ==~ /examples/) {
				println("Ignoring " + it)
				return
			}
			
			def dir = new File(it)
			
			dir.eachDir { subfolder ->
				build_library(subfolder, staticDir)
			}
		}
	}
}

// Task to upload .hex to device.
task upload(dependsOn: build) {
	doLast {
		cmd = ["$arduinoDir\\hardware\\tools\\avr\\bin\\avrdude",
			"-C$arduinoDir\\hardware\\tools\\avr\\etc\\avrdude.conf",
			"-v",
			"-v",
			"-v",
			"-v",
			"-p$cpuName",
			"-carduino",
			"-P\\\\.\\$comPort",
			"-b115200",
			"-D",
			"-Uflash:w:$shortBuildDir\\${sketchMainFile}.hex:i"]
		exec_cmd(cmd)
	}
}

// Task to clean directories.
task clean {
	doLast {
		// kill build directory
		ant.delete(dir: buildDir)
	}
}*/